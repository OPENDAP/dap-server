
 $Id: README,v 1.4 1996/10/08 19:48:19 jimg Exp $

There are four executables used in the DODS-Matlab interface:

1) loaddods; a mex program run by Matlab. This program must be accessible to
Matlab. It can be placed in either a user's directory from scripts and
extensions or in a system-wide directory. loaddods can be used in three ways:
a) when run with a URL as its argument the program assumes that the URL is a
fully qualified DODS URL and invokes writeval to get the associated data, b)
with no argument at all, loaddods waits for a URL to be sent via the urlqueue
program and c) if loaddods is run with `?' as its argument, then the program
will start Netscape and open the DODS locator main page. Thus loaddods is a
very flexible program since you can use it with a URL saved or cut from some
other source, with the HTML interface we have built, with some other
interface or after you have found some data with the browser.

2) writeval; dereferences a DODS URL and returns a binary stream of data.
This can be installed anywhere on the system, but its path is hard coded into
the loaddods program so unless you want to modify the loaddods source code it
should be placed in the same directory as loaddods. While this program is
used by loaddods, it could be used for other purposes as well. For example a
user could save binary data to a file with writeval.

3) urlqueue; a helper application for Netscape (or other WWW browser) which
passes information from a browser to another program such as loaddods. The
file `mailcap' contains a sample mailcap file entry for the helper
application

4) posturl; Users do not need to have this on their system. It is included
here for completeness. However, if users want to write their own HTML forms
for building URLs then they can install and use their own copy of posturl and
make a completely self contained system. 

------------

Here is a pseudo grammar describing the output of writeval. I used * as the
Kleene closure (zero or more) and + a one or more. Basically, the idea is
simple; write the type and name of the variable on one line and data for it
on the next. For ctor types it becomes more complex, but not much. For arrays
write Array, the type, the name, the number of dimensions and a list of
dimension sizes on one line and the data on the next line. 

Sequences are handled specially because of a possible bug in the core
software. I `flatten' sequences so that a DDS like:
	  Dataset {
		  Sequence {
			   Int32 a;
			   Int32 b;
			   Sequence {
				    Float64 c;
		           } inner;
		  } outer;
	  } ds;
Will look like:
	  Dataset {
		  Sequence {
			   Int32 a;
			   Int32 b;
			   Float64 c;
		  } outer;
	  } ds;

Also note that Sequences of ctor types other than Sequence cannot be
flattened and thus will fail. I believe that the failure won't crash, but
some data will be lost.

<data request> :: <variable>*

<variable> :: <type name> 

<simple variable> :: ' ' <variable name> '\n' <data values>

<array variable> :: ' ' <variable name> <number of dims> <dim size>+

<list variable> :: ' ' <variable name> <list size>

<struct variables> :: <variable name> <num of elements> '\n' <variable>* '\n'
		      <data>*
NB: the number of <variable> matches the number of <data>

<sequence variables> :: <variable name> <num of elements> '\n' <variable>* '\n'
		        <data>*
NB: the number of <data> is an integral multiple of <variable>.

<variable> :: Byte <simple variable> '\n' <data> '\n'
	   :: Int32 <simple variable> '\n' <data> '\n'
	   :: Float64 <simple variable> '\n'  <data> '\n'
	   :: Str <simple variable> '\n' <data> '\n'
	   :: Url <simple variable> '\n' <data> '\n'
	   :: Array <array variable> '\n' <data> '\n'
	   :: List <list variable> '\n' <data> '\n'
	   :: Structure <struct variables> `\n'
	   :: Sequence <sequence variables> '\n'
	   :: Grid <variable name> '\n' 'array: \n' <array variable> <data>
	      'map: \n' <array variable>+ <data>+
NB: The number of the second <array variable> and <data> must match.

James Gallagher 10/4/96