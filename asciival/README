
 $Id: README,v 1.17 1998/11/19 20:53:59 jimg Exp $

The following provides background technical information on the design of
loaddods/writeval and asciival. For installation information, see the file
INSTALL-matlab-client and for help using the matlab command `loaddods', see
the on-line help for that command (in Matlab type `help loaddods'). Make sure
that the file loaddods.m is in the same directory as the loaddods.mex*
program.

Note that the configure script for this directory checks for Matlab but only
issues a warning if it is not found. Of the three programs loaddods, writeval
and asciival, only loaddods needs the Matlab libraries. 

ASCIIVAL: The program asciival is a filter that is similar to writeval
(described later in conjunction with loaddods) that can function as both a
client and a server filter program. asciival can read data from a URL, a
local filename or from standard input. The program prints to standard output
an ASCII version of the data where columns are separated by commas and rows
separated by newlines. Users can request data from serves in ASCII form using
the suffix .ascii or .asc in a DODS URL. To see how the asciival program is
used on the server side, look at the DODS_Dispatch.pm Perl module.

I think that asciival should be moved to the dap directory ASAP. 5/22/98 jhrg

WRITEVAL:
There are two programs that comprise the DODS-Matlab command line interface;
loaddods and whodods. They are analogous to Matlab's load and who commands.
However, they accept DODS URLs rather than Matlab files. On-line help is
available for both commands - make sure that you have the loaddods.m,
loaddods.mex* and whodods.m file in a directory that Matlab will search for
binaries.

Here is a summary of the software in the entire DODS Matlab client (including
parts that users don't see and optional parts):

1) loaddods; A cmex program run by Matlab. This program must be on a
directory Matlab search when looking for command files. It can be placed in
either a user's directory for scripts and extensions or in a system-wide
directory.

loaddods accepts several command line switches some of which are listed below:
   -V: get the version of loaddods and writeval
   -g: activate the GUI.
   (-/+)v: turn on/off verbose mode (it is on by default). 
   -k: turn on variable catenation.
   -n: turn on fullnames.
   -s: return a matrix of variable names - only works with the return args
       form of the command.   

   NB: other options will be passed to writeval for processing. Of these -F
   and -A are the most important. See the on line help for loaddods or
   writeval. 

When called with a command switch, you must give that switch first and it
must be quoted. E.G.: loaddods('-g', 'http://...'). See the online help file
for the complete list of switches.

loaddods can be used in four ways:

a) When run with a URL as its argument the program assumes that the URL is a
fully qualified DODS URL and invokes writeval to get the associated data,

b) If loaddods is run with `*' or '?' as its argument, the program will start
Netscape and open the DODS locator main page,

c) A URL prefixed by a `*' or `?' will be passed to netscape and used as an
alternative data locator page.

d) With no argument at all, loaddods waits for a URL to be sent via a WWW
browser.

loaddods is a very flexible program since you can use it with a URL
saved or cut from some other source, with the HTML interface we have built,
with some other interface or after you have found some data with the browser.

2) writeval; Dereferences a DODS URL and returns a mixed ASCII and binary
stream of data. loaddods calls writeval to perform the actual data fetch so
this program must be in a directory on the user's PATH or in DODS_ROOT/etc.
Note that you can set DODS_ROOT as a shell variable *or* use the value
compiled into the software. While this program was originally intended to be
used with loaddods, it can also be used for other purposes as well. For
example a user could save binary data to a file with writeval. Note that with
the `-f' option writeval translates all simple types to either Float64 or
String.

writeval can also be used to read from standard input, write ASCII output and
access the DDS for a given dataset. See the online help for information about
these options. 

3) urlqueue; A helper application for Netscape (or other WWW browser) which
passes information from a browser to another program such as loaddods. 

4) posturl.pl; Users do not need to have this on their system. It is included
here for completeness. However, if users want to write their own HTML forms
for building URLs then they can install and use their own copy of posturl and
make a completely self contained system.

5) whodods; print the Dataset Descriptor Structure for the URL. This provides
a way to look at the structure of a dataset without leaving Matlab. It can be
thought of as a simple alternative to the HTML-based GUI (although users
don't need to leave Matlab to use that either...).

------------

Here is a pseudo grammar describing the output of writeval. I used * as the
Kleene closure (zero or more) and + as one or more. The idea is simple; write
the type and name of the variable each on one line and data for it on the
following line. For ctor types it becomes more complex, but not much. For
arrays write Array, newline, the type, the name, the number of dimensions,
newline, a list of dimension sizes, newline and the data. Finish by writing a
newline.

While this means sending out some extra charaters it makes the output of
writeval very simple to parse.

10/31/97 jhrg: Changed string data format; strings are individually
terminated by a newline. A second newline follows the last string.

<data request> :: <variable>*

<variable> :: <simple variable>
	   :: <vector variable>
	   :: <constructor variable>

<simple variable> :: Byte '\n' <variable name> '\n' <data> '\n'
		  :: Int32 '\n' <variable name> '\n' <data> '\n'
		  :: Float64 '\n' <variable name> '\n'  <data> '\n'
		  :: String '\n' <variable name> '\n' <string data> '\n'
		  :: Url '\n' <variable name> '\n' <string data> '\n'

<vector variable> :: Array '\n' <array variable> '\n' <data> [see note 1]
		  :: List '\n' <list variable> '\n' <data>

<constructor variable> :: Structure '\n' <struct variables> 
		       :: Sequence '\n' <sequence variables>
		       :: Grid '\n' <grid variables>

<string data> :: <string 0> '\n' <string 1> '\n' ... <string n> '\n'

<array variable> :: <variable type> ' ' <variable name> ' ' 
		    <number of dims> '\n' <dim size>+ 

<list variable> :: <variable type> <variable name> <list size>

<struct variables> :: <variable name> <num of elements> '\n' 
		      (<variable>)+

<sequence variables> :: <variable name> <num of elements> '\n' 
			(<variable>)+

<grid variables> :: <variable name> '\n' 'array '\n' <array variable>
		    'map <num of arrays>\n' (<array variable>)+ 

<error> :: Error '\n' <message> '\n'

Notes:

1) The vector type's data is sent using the print_val() method of the
vector's contained type. That is, for a vector of int32s, the contained type
is int32 and the int32 class' print_val() is used to send the vector's
values. This method writes binary values and terminates them with a `\n'.
Thus, the vector variable's print_val() methods do not need to send the `\n'.
Since we know that all vector and ctor types must ultimately `lead to' simple
types, it is sufficient to have the simple types handle writing the `\n'
separators. Having the ctors (and vectors) do this too just means more
information for the recipient to parse.

James Gallagher 10/4/96

