#!@PERL@ -T
# -*- Perl -*-

# This file is part of libdap, A C++ implmentation of the OPeNDAP Data
# Access Protocol.

# Copyright (c) 2002,2003 OPeNDAP, Inc.
# Author: James Gallagher <jgallagher@opendap.org>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.

# Make sure that the path after the `#!' at the start of this file is the
# path to Perl on your system. If there are several versions of perl, make
# sure this points to a perl that is at least version 5.004.

# This script handles the dispatch of the URL to one of the filter programs
# that makes up the DODS server. The filter program is executed by this
# script using exec. If the filter program cannot be run, an error message
# will be returned.
#
# See the DODS_Dispatch.pm class for information about how environment
# variables are used.
#
# NB: This script assumes that all data is rooted in the http document
# directory subtree. If you want to access files outside that subtree, use a
# symbolic link and make sure that your server is set to follow symbolic
# links. To configure an Apache server to follow symbolic links, add
# FollowSymLinks to the Options in the httpd.conf file.
#
# Options: -T: use Perl's taint mode.
#
# $Id$

# Force PATH. This should work for most UNIXs. Forcing PATH means that -T
# (taint) won't complain about running programs. Perl will consider any
# directory that's writeable by someone other than the owner as tainted, so
# adding, for example, /usr/local/bin here might break other operations
# (places where we use exec in DODS_Dispatch or DODS_Cache).

$ENV{PATH} = "/bin:/usr/bin:@bindir@";
$ENV{IFS} = "" if $ENV{IFS};    # For the truly paranoid...

# Needed for Perl 5.6.0 on Linux 12/11/2000 jhrg
$ENV{BASH_ENV} = '';

# These environment variables are used by the JGOFS server when there's no
# JGOFS user on the host system. 5/31/2001 jhrg
# Assume this script will run in the cgi-bin directory and that all dap-server
# configuration files will also be in that directory. 5/17/2005 jhrg
$ENV{"JGOFS_OBJECT"} = "`pwd`";
$ENV{"JGOFS_METHOD"} = "`pwd`";

use lib ("@dap_modulesdir@");
use DODS_Dispatch;
use DODS_Cache;

my $bad_command = "The DODS server dispatch software could not figure out how
to handle this request. Please check that the URL is correct. If you're sure
this should work, please contact the ";

# The DODS_Dispatch object reads information from environment variables
# and builds up a command based on the format of a DODS URL.
$dispatch = new DODS_Dispatch( "DAP2/@PACKAGE_VERSION@", "@dap_cgiconfdir@/dap-server.rc" );

# Note that the statistics 'stuff' has its own configuration file. That's
# because we're just evaluating this feature. 07/22/03 jhrg

# Small change: if there's a file called OPENDAP_STATISTICS in the CWD, then
# stats are on. The installServers script will create this in response to
# questions, but we can crate it too, so running the installServers script
# every time the servers change is no longer necessary. 09/27/02 jhrg
# I think we should probably move this information into the dods.conf/ini
# file. The reason for keeping it separate is that we want to make sure that
# this feature is not turned on accidentally. 10/23/02 jhrg
if ( -f "OPENDAP_STATISTICS" ) {
    $dispatch->is_stat_on(1);

    open( STATS, "OPENDAP_STATISTICS" );

  LINE:
    while (<STATS>) {
        next LINE if /^\#/;
        next LINE if /^$/;

        my ( $name, $value ) = split;

        if ( $name eq "access_log" ) {
            $dispatch->access_log($value);    # Path to httpd's access log
        } elsif ( $name eq "error_log" ) {
            $dispatch->error_log($value);     # Path to http'd error log
        } elsif ( $name eq "machine_names" ) {
            $dispatch->machine_names($value);  # Regex of names for this machine
        }
    }
} else {
    $dispatch->is_stat_on(0);      # Set to 1 if statistics are turned on.
    $dispatch->access_log();       # Path to httpd's access log
    $dispatch->error_log();        # Path to http'd error log
    $dispatch->machine_names();    # PERL Regex of names for this machine
}

my $compressed = is_compressed( $dispatch->filename() );

if ( $compressed ) {
    purge_cache( $dispatch->cache_dir(), $dispatch->cache_size() );

    my ( $cache_entity, $error );

    ( $cache_entity, $error ) =
        decompress_and_cache( $dispatch->filename(), $dispatch->cache_dir() );

    $dispatch->print_error_msg( $error, 0 )
        if ( $cache_entity eq "" && $error ne "" );

    $dispatch->filename($cache_entity);
}

@command = $dispatch->command();

if ( $command[0] ne "" ) {    # if no error...
    exec(@command);
} else {
    $dispatch->print_error_msg( $bad_command, 1 );
}

